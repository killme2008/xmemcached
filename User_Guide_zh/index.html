<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

 


 
 
 


 
 
 
 <title>User_Guide_zh - 
 xmemcached -
 
 用户指南 - Project Hosting on Google Code</title>
 
 
 
 
 
 
 
 
 
<!--[if IE]>
 <link type="text/css" rel="stylesheet" href="http://www.gstatic.com/codesite/ph/2429932258724909799/css/d_ie.css" >
<![endif]-->
 

<link rel="stylesheet" type="text/css" href="index.css" media="all">
</head>
<body class="t6">
<div id="maincol" style="margin: 0pt; padding: 0pt 3px 3px 0pt;">
<div id="wikicontent">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody>
<tr>
<td class="vt" id="wikimaincol" width="100%">
<!--DOCUMENT_FRAGMENT-->
<div id="wikiheader" style="margin-bottom: 1em;"><span style="font-size: 120%; font-weight: bold;">User_Guide_zh</span>
 &nbsp;
 
 
 <div style="font-style: italic; margin-top: 3px;">用户指南</div>
 
 </div>
 <p></p><ul><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#XMemcached%E7%AE%80%E4%BB%8B">XMemcached简介</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#XMemcached%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7">XMemcached的主要特性</a></li><ul><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E9%AB%98%E6%80%A7%E8%83%BD">高性能</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E6%94%AF%E6%8C%81%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8D%8F%E8%AE%AE">支持完整的协议</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E6%94%AF%E6%8C%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E5%B8%83">支持客户端分布</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E5%85%81%E8%AE%B8%E8%AE%BE%E7%BD%AE%E8%8A%82%E7%82%B9%E6%9D%83%E9%87%8D">允许设置节点权重</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E5%8A%A8%E6%80%81%E5%A2%9E%E5%88%A0%E8%8A%82%E7%82%B9">动态增删节点</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E6%94%AF%E6%8C%81JMX">支持JMX</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E4%B8%8ESpring%E6%A1%86%E6%9E%B6%E5%92%8CHibernate-memcached%E7%9A%84%E9%9B%86%E6%88%90">与Spring框架和Hibernate-memcached的集成</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%B1%A0">客户端连接池</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7">可扩展性</a></li></ul><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97">使用指南</a></li><ul><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90">简单例子</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#CAS%E6%93%8D%E4%BD%9C">CAS操作</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E6%9B%B4%E5%85%A8%E9%9D%A2%E7%9A%84%E4%BE%8B%E5%AD%90">更全面的例子</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#Incr/Decr">Incr/Decr</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E6%9F%A5%E7%9C%8B%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF">查看统计信息</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98">高级主题</a></li><ul><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E4%B8%8ESpring%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90">与Spring框架集成</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E8%AE%BE%E7%BD%AE%E8%8A%82%E7%82%B9%E6%9D%83%E9%87%8D">设置节点权重</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%8F%E8%AE%AE">使用二进制协议</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#JMX%E6%94%AF%E6%8C%81">JMX支持</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0/%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9">动态添加/删除节点</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#Nio%E8%BF%9E%E6%8E%A5%E6%B1%A0">Nio连接池</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E4%B8%8EKestrel%E4%BA%A4%E4%BA%92">与Kestrel交互</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E4%B8%8EHibernate-memcached%E9%9B%86%E6%88%90">与Hibernate-memcached集成</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E5%8E%8B%E7%BC%A9%E3%80%81sanitizeKeys%E7%AD%89%E6%9D%82%E9%A1%B9">压缩、sanitizeKeys等杂项</a></li><ul><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9">数据压缩</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#packZeros">packZeros</a></li><li><a href="http://code.google.com/p/xmemcached/wiki/User_Guide_zh#sanitizeKeys">sanitizeKeys</a></li></ul></ul></ul></ul> <h1><a name="XMemcached简介">XMemcached简介</a></h1><p><a name="XMemcached简介">XMemcached是一个新java memcached client。也许你还不知道memcached是什么？可以先看看</a><a href="http://code.google.com/p/memcached/" rel="nofollow">这里</a>。简单来说，Memcached 是一个高性能的分布式内存对象的key-value缓存系统，用于动态Web应用以减轻数据库负载，现在也有很多人将它作为内存式数据库在使用，memcached通过它的自定义协议与客户端交互，而XMemcached就是它的一个java客户端实现。 </p><p>Memcached的java客户端已经存在两个了：官方提供的基于传统阻塞io由<a href="http://www.whalin.com/memcached/" rel="nofollow">Greg Whalin维护的客户端</a>、Dustin Sallings实现的基于java nio的<a href="http://code.google.com/p/spymemcached" rel="nofollow">Spymemcached</a>。另外还有一些在此基础上的改进版本。相比于这些客户端，XMemcached有什么优点呢？或者说，它的主要特性有哪些？ </p><h1><a name="XMemcached的主要特性">XMemcached的主要特性</a></h1><h2><a name="高性能">高性能</a></h2><p><a name="高性能">XMemcached同样是基于java nio的客户端，java nio相比于传统阻塞io模型来说，有效率高（特别在高并发下）和资源耗费相对较少的优点。传统阻塞IO为了提高效率，需要创建一定数量的连接形成连接池，而nio仅需要一个连接即可（当然,nio也是可以做池化处理），相对来说减少了线程创建和切换的开销，这一点在高并发下特别明显。因此XMemcached与Spymemcached在性能都非常优秀，在某些方面（存储的数据比较小的情况下）Xmemcached比Spymemcached的表现更为优秀，具体可以看这个</a><a href="http://xmemcached.googlecode.com/svn/trunk/benchmark/benchmark.html" rel="nofollow">Java Memcached Clients Benchmark</a>。 </p><h2><a name="支持完整的协议">支持完整的协议</a></h2><p><a name="支持完整的协议">Xmemcached支持所有的memcached协议，包括1.4.0正式开始使用的</a><a href="http://code.google.com/p/memcached/wiki/MemcacheBinaryProtocol" rel="nofollow">二进制协议</a>。 </p><h2><a name="支持客户端分布">支持客户端分布</a></h2><p><a name="支持客户端分布">Memcached的分布只能通过客户端来实现，XMemcached实现了此功能，并且提供了一致性哈希(consistent hash)算法的实现。 </a></p><h2><a name="允许设置节点权重">允许设置节点权重</a></h2><p><a name="允许设置节点权重">XMemcached允许通过设置节点的权重来调节memcached的负载，设置的权重越高，该memcached节点存储的数据将越多，所承受的负载越大。 </a></p><h2><a name="动态增删节点">动态增删节点</a></h2><p><a name="动态增删节点">XMemcached允许通过JMX或者代码编程实现节点的动态添加或者移除，方便用户扩展和替换节点等。 </a></p><h2><a name="支持JMX">支持JMX</a></h2><p><a name="支持JMX">XMemcached通过JMX暴露的一些接口，支持client本身的监控和调整，允许动态设置调优参数、查看统计数据、动态增删节点等。 </a></p><h2><a name="与Spring框架和Hibernate-memcached的集成">与Spring框架和Hibernate-memcached的集成</a></h2><p><a name="与Spring框架和Hibernate-memcached的集成">鉴于很多项目已经使用Spring作为IOC容器，因此XMemcached也提供了对Spring框架的集成支持。</a><a href="http://code.google.com/p/hibernate-memcached/" rel="nofollow">Hibernate-memcached</a>是一个允许将memcached作为hibernate的二级缓存的开源项目，默认是使用Spymemcached，Xmemcached提供了对这个项目的支持，允许替换Spymemcached. </p><h2><a name="客户端连接池">客户端连接池</a></h2><p><a name="客户端连接池">刚才已经提到java nio通常对一个memcached节点使用一个连接，而XMemcached同样提供了设置连接池的功能，对同一个memcached可以创建N个连接组成连接池来提高客户端在高并发环境下的表现，而这一切对使用者来说却是透明的。启用连接池的前提条件是保证数据之间的独立性或者数据更新的同步，对同一个节点的各个连接之间是没有做更新同步的，因此应用需要保证数据之间是相互独立的或者全部采用CAS更新来保证原子性。 </a></p><h2><a name="可扩展性">可扩展性</a></h2><p><a name="可扩展性">XMemcached是基于java nio框架</a><a href="http://code.google.com/p/yanf4j/" rel="nofollow">yanf4j</a>实现的，因此在实现上结构相对清楚，分层比较明晰，下面是XMemcached的主要类的UML图: </p><p><img src="main.cld.jpg"> </p><h1><a name="使用指南">使用指南</a></h1><p><a name="使用指南">在简单介绍完XMemcached的主要特性之后，我们将进入XMemcached的使用环节，这里将按照从简单到复杂的顺序讲解一些例子，以方便用户深入了解XMemcached的使用。 </a></p><h2><a name="简单例子">简单例子</a></h2><p><a name="简单例子">对于用户来说，最主要的功能是存取数据，假设我们有一个memcached节点IP地址或者域名是host，端口是11211，一个简单的存取数据的例子如下： </a></p><pre class="prettyprint"><a name="简单例子"><span class="pln">&nbsp; &nbsp; </span><span class="typ">MemcachedClientBuilder</span><span class="pln"> builder </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">XMemcachedClientBuilder</span><span class="pun">(</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">AddrUtil</span><span class="pun">.</span><span class="pln">getAddresses</span><span class="pun">(“</span><span class="pln">host</span><span class="pun">:</span><span class="lit">11211</span><span class="pun">”));</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="typ">MemcachedClient</span><span class="pln"> memcachedClient </span><span class="pun">=</span><span class="pln"> builder</span><span class="pun">.</span><span class="pln">build</span><span class="pun">();</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcachedClient</span><span class="pun">.</span><span class="kwd">set</span><span class="pun">(</span><span class="str">"hello"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Hello,xmemcached"</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">String</span><span class="pln"> value </span><span class="pun">=</span><span class="pln"> memcachedClient</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">"hello"</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"hello="</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> value</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcachedClient</span><span class="pun">.</span><span class="kwd">delete</span><span class="pun">(</span><span class="str">"hello"</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value </span><span class="pun">=</span><span class="pln"> memcachedClient</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">"hello"</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"hello="</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> value</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="typ">MemcachedException</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">System</span><span class="pun">.</span><span class="pln">err</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"MemcachedClient operation fail"</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e</span><span class="pun">.</span><span class="pln">printStackTrace</span><span class="pun">();</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="typ">TimeoutException</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">System</span><span class="pun">.</span><span class="pln">err</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"MemcachedClient operation timeout"</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e</span><span class="pun">.</span><span class="pln">printStackTrace</span><span class="pun">();</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="typ">InterruptedException</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">// ignore</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">//close memcached client</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcachedClient</span><span class="pun">.</span><span class="pln">shutdown</span><span class="pun">();</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="typ">IOException</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">System</span><span class="pun">.</span><span class="pln">err</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Shutdown MemcachedClient fail"</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e</span><span class="pun">.</span><span class="pln">printStackTrace</span><span class="pun">();</span><span class="pln"><br>&nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br></span></a></pre><p><a name="简单例子">因为XMemcachedClient的创建有比较多的可选项，因此提供了一个XMemcachedClientBuilder类用于构建MemcachedClient。MemcachedClient是主要接口，操作memcached的主要方法都在这个接口，XMemcachedClient是它的一个实现。传入的memcached节点列表要求是类似<strong>"host1:port1 host2:port2 …"</strong>这样的字符串，通过AddrUtil.getAddresses方法获取实际的IP地址列表。 </a></p><p><a name="简单例子">存储数据是通过set方法，它有三个参数，第一个是存储的key名称，第二个是expire时间（单位秒），超过这个时间,memcached将这个数据替换出去，0表示永久存储（默认是一个月），第三个参数就是实际存储的数据，可以是任意的java可序列化类型。获取存储的数据是通过get方法，传入key名称即可。如果要删除存储的数据，这是通过delete方法，它也是接受key名称作为参数。XMemcached由于是基于nio，因此通讯过程本身是异步的，client发送一个请求给memcached，你是无法确定memcached什么时候返回这个应答，客户端此时只有等待，因此还有个等待超时的概念在这里。客户端在发送请求后，开始等待应答，如果超过一定时间就认为操作失败，这个等待时间默认是一秒，上面例子展现的3个方法调用的都是默认的超时时间，这三个方法同样有允许传入超时时间的重载方法，例如 </a></p><pre class="prettyprint"><a name="简单例子"><span class="pln">&nbsp; &nbsp;value</span><span class="pun">=</span><span class="pln">client</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(“</span><span class="pln">hello</span><span class="pun">”,</span><span class="lit">3000</span><span class="pun">);</span></a></pre><p><a name="简单例子">就是等待3秒超时，如果3秒超时就跑出TimeutException，用户需要自己处理这个异常。因为等待是通过调用CountDownLatch.await(timeout)方法，因此用户还需要处理中断异常InterruptException。最后的MemcachedException表示Xmemcached内部发生的异常，如解码编码错误、网络断开等等异常情况。 </a></p><h2><a name="CAS操作">CAS操作</a></h2><p><a name="CAS操作">Memcached是通过cas协议实现原子更新，所谓原子更新就是compare and set，原理类似乐观锁，每次请求存储某个数据同时要附带一个cas值，memcached比对这个cas值与当前存储数据的cas值是否相等，如果相等就让新的数据覆盖老的数据，如果不相等就认为更新失败，这在并发环境下特别有用。XMemcached提供了对CAS协议的支持（无论是文本协议还是二进制协议），CAS协议其实是分为两个步骤：获取CAS值和尝试更新，因此一个典型的使用场景如下： </a></p><pre class="prettyprint"><a name="CAS操作"><span class="pln">&nbsp; </span><span class="typ">GetsResponse</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;</span><span class="pln"> result </span><span class="pun">=</span><span class="pln"> client</span><span class="pun">.</span><span class="pln">gets</span><span class="pun">(</span><span class="str">"a"</span><span class="pun">);</span><span class="pln"><br>&nbsp; </span><span class="kwd">long</span><span class="pln"> cas </span><span class="pun">=</span><span class="pln"> result</span><span class="pun">.</span><span class="pln">getCas</span><span class="pun">();</span><span class="pln"> <br>&nbsp; </span><span class="com">//尝试将a的值更新为2</span><span class="pln"><br>&nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">client</span><span class="pun">.</span><span class="pln">cas</span><span class="pun">(</span><span class="str">"a"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> cas</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">System</span><span class="pun">.</span><span class="pln">err</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"cas error"</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="pun">}</span><span class="pln"><br></span></a></pre><p><a name="CAS操作">首先通过gets方法获取一个GetsResponse，此对象包装了存储的数据和cas值，然后通过cas方法尝试原子更新，如果失败打印”cas error”。显然，这样的方式很繁琐，并且如果你想尝试多少次原子更新就需要一个循环来包装这一段代码，因此XMemcached提供了一个*CASOperation*接口包装了这部分操作，允许你尝试N次去原子更新某个key存储的数据，无需显式地调用gets获取cas值,上面的代码简化为: </a></p><pre class="prettyprint"><a name="CAS操作"><span class="pln">&nbsp;client</span><span class="pun">.</span><span class="pln">cas</span><span class="pun">(</span><span class="str">"a"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">CASOperation</span><span class="pun">&lt;</span><span class="typ">Integer</span><span class="pun">&gt;()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> getMaxTries</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">Integer</span><span class="pln"> getNewValue</span><span class="pun">(</span><span class="kwd">long</span><span class="pln"> currentCAS</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Integer</span><span class="pln"> currentValue</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="pun">});</span><span class="pln"><br></span></a></pre><p><a name="CAS操作">CASOpertion接口只有两个方法，一个是设置最大尝试次数的getMaxTries方法，这里是尝试一次，如果尝试超过这个次数没有更新成功将抛出一个TimeoutException，如果你想无限尝试（理论上），可以将返回值设定为Integer.MAX_VALUE；另一个方法是根据当前获得的GetsResponse来决定更新数据的getNewValue方法，如果更新成功，这个方法返回的值将存储成功，这个方法的两个参数是最新一次gets返回的GetsResponse结果。 </a></p><h2><a name="更全面的例子">更全面的例子</a></h2><p><a name="更全面的例子">一些更全面的例子，展现了MemcachedClient接口的主要方法： </a></p><pre class="prettyprint"><a name="更全面的例子"><span class="pln">&nbsp; </span><span class="typ">MemcachedClientBuilder</span><span class="pln"> builder </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">XMemcachedClientBuilder</span><span class="pun">(</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">AddrUtil</span><span class="pun">.</span><span class="pln">getAddresses</span><span class="pun">(“</span><span class="pln">localhost</span><span class="pun">:</span><span class="lit">12000</span><span class="pun">”));</span><span class="pln"><br>&nbsp; </span><span class="typ">MemcachedClient</span><span class="pln"> client </span><span class="pun">=</span><span class="pln"> builder</span><span class="pun">.</span><span class="pln">build</span><span class="pun">();</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; client</span><span class="pun">.</span><span class="pln">flushAll</span><span class="pun">();</span><span class="pln"><br>&nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">client</span><span class="pun">.</span><span class="kwd">set</span><span class="pun">(</span><span class="str">"hello"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="str">"world"</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">System</span><span class="pun">.</span><span class="pln">err</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"set error"</span><span class="pun">);</span><span class="pln"><br>&nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">client</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="str">"hello"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="str">"dennis"</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">System</span><span class="pun">.</span><span class="pln">err</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"Add error,key is existed"</span><span class="pun">);</span><span class="pln"><br>&nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">client</span><span class="pun">.</span><span class="pln">replace</span><span class="pun">(</span><span class="str">"hello"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="str">"dennis"</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="typ">System</span><span class="pun">.</span><span class="pln">err</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="str">"replace error"</span><span class="pun">);</span><span class="pln"><br>&nbsp; </span><span class="pun">}</span><span class="pln"><br>&nbsp; client</span><span class="pun">.</span><span class="pln">append</span><span class="pun">(</span><span class="str">"hello"</span><span class="pun">,</span><span class="pln"> </span><span class="str">" good"</span><span class="pun">);</span><span class="pln"><br>&nbsp; client</span><span class="pun">.</span><span class="pln">prepend</span><span class="pun">(</span><span class="str">"hello"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"hello "</span><span class="pun">);</span><span class="pln"><br>&nbsp; </span><span class="typ">String</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> client</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">"hello"</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StringTranscoder</span><span class="pun">());</span><span class="pln"><br>&nbsp; </span><span class="typ">System</span><span class="pun">.</span><span class="kwd">out</span><span class="pun">.</span><span class="pln">println</span><span class="pun">(</span><span class="pln">name</span><span class="pun">);</span><span class="pln"><br>&nbsp; client</span><span class="pun">.</span><span class="pln">deleteWithNoReply</span><span class="pun">(“</span><span class="pln">hello</span><span class="pun">”);</span><span class="pln"><br></span></a></pre><p><a name="更全面的例子">首先存储了hello对应的world字符串，然后调用add和replace方法去尝试添加和替换，因为数据已经存在，因此add会失败，同样replace在数据存在的情况才会成功，也就是将hello对应的数据更新为dennis，然后通过append和prepend方法在dennis前后加上了字符串hello和good，因此通过get返回的结果是hello dennis good。而删除数据则是通过deleteWithNoReply方法，这个方法删除数据并且告诉memcached不用返回应答，因此这个方法不会等待应答直接返回，特别适合于批量处理；同样地，set、add、replace等方法也有相应的withNoReply重载版本，具体请看API文档。 </a></p><h2><a name="Incr/Decr">Incr/Decr</a></h2><p><a name="Incr/Decr">下面这个例子展现了incr/decr操作的使用，两个操作类似Java中的原子类如AtomicIntger，用于原子递增或者递减变量数值： </a></p><pre class="prettyprint"><a name="Incr/Decr"><span class="pln">&nbsp;</span><span class="kwd">assert</span><span class="pun">(</span><span class="lit">1</span><span class="pun">==</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">memcachedClient</span><span class="pun">.</span><span class="pln">incr</span><span class="pun">(</span><span class="str">"a"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">5</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">));</span><span class="pln"><br>&nbsp;</span><span class="kwd">assert</span><span class="pun">(</span><span class="lit">6</span><span class="pun">==</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">memcachedClient</span><span class="pun">.</span><span class="pln">incr</span><span class="pun">(</span><span class="str">"a"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">5</span><span class="pun">));</span><span class="pln"><br>&nbsp;</span><span class="kwd">assert</span><span class="pun">(</span><span class="lit">10</span><span class="pun">==</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">memcachedClient</span><span class="pun">.</span><span class="pln">incr</span><span class="pun">(</span><span class="str">"a"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">));</span><span class="pln"><br>&nbsp;</span><span class="kwd">assert</span><span class="pun">(</span><span class="lit">9</span><span class="pun">==</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">memcachedClient</span><span class="pun">.</span><span class="pln">decr</span><span class="pun">(</span><span class="str">"a"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">));</span><span class="pln"><br>&nbsp;</span><span class="kwd">assert</span><span class="pun">(</span><span class="lit">7</span><span class="pun">==</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">memcachedClient</span><span class="pun">.</span><span class="pln">deccr</span><span class="pun">(</span><span class="str">"a"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">));</span><span class="pln"><br></span></a></pre><p><a name="Incr/Decr">incr和decr都有三个参数的方法，第一个参数指定递增的key名称，第二个参数指定递增的幅度大小，第三个参数指定当key不存在的情况下的初始值。两个参数的重载方法省略了第三个参数，默认指定为0 </a></p><h2><a name="查看统计信息">查看统计信息</a></h2><p><a name="查看统计信息">Memcached提供了统计协议用于查看统计信息： </a></p><pre class="prettyprint"><a name="查看统计信息"><span class="pln">&nbsp; &nbsp;</span><span class="typ">Map</span><span class="pun">&lt;</span><span class="typ">InetSocketAddress</span><span class="pun">,</span><span class="typ">Map</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">,</span><span class="typ">String</span><span class="pun">&gt;&gt;</span><span class="pln"> result</span><span class="pun">=</span><span class="pln">client</span><span class="pun">.</span><span class="pln">getStats</span><span class="pun">();</span></a></pre><p><a name="查看统计信息">getStats方法返回一个map，其中存储了所有已经连接并且有效的memcached节点返回的统计信息，你也可以统计具体的项目，如统计items项目： </a></p><pre class="prettyprint"><a name="查看统计信息"><span class="pln">&nbsp; &nbsp;</span><span class="typ">Map</span><span class="pun">&lt;</span><span class="typ">InetSocketAddress</span><span class="pun">,</span><span class="typ">Map</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">,</span><span class="typ">String</span><span class="pun">&gt;&gt;</span><span class="pln"> result</span><span class="pun">=</span><span class="pln">client</span><span class="pun">.</span><span class="pln">getStatsByItem</span><span class="pun">(</span><span class="str">"items"</span><span class="pun">);</span></a></pre><p><a name="查看统计信息">只要向getStatsByItem传入需要统计的项目名称即可。 </a></p><h2><a name="高级主题">高级主题</a></h2><h3><a name="与Spring框架集成">与Spring框架集成</a></h3><p><a name="与Spring框架集成">通过XMemcachedClientFactoryBean类，即可与spring框架集成，简单的配置如下： </a></p><pre class="prettyprint"><a name="与Spring框架集成"><span class="tag">&lt;bean</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"memcachedClient"</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"net.rubyeye.xmemcached.utils.XMemcachedClientFactoryBean"</span><span class="pln"> </span><span class="atn">destroy-method</span><span class="pun">=</span><span class="atv">"shutdown"</span><span class="tag">&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;property</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"servers"</span><span class="tag">&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;value&gt;</span><span class="pln">host1:port1 host2:port2</span><span class="tag">&lt;/value&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;/property&gt;</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="tag">&lt;/bean&gt;</span></a></pre><p><a name="与Spring框架集成">那么你就可以在需要使用MemcachedClient的地方引用这个bean. </a></p><p><a name="与Spring框架集成">更完整的配置例子，设置协议类型、一致性哈希、权重、连接池大小，具体请看注释： </a></p><pre class="prettyprint"><a name="与Spring框架集成"><span class="tag">&lt;bean</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"memcachedClient"</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"net.rubyeye.xmemcached.utils.XMemcachedClientFactoryBean"</span><span class="pln"> </span><span class="atn">destroy-method</span><span class="pun">=</span><span class="atv">"shutdown"</span><span class="tag">&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;property</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"servers"</span><span class="tag">&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;value&gt;</span><span class="pln">host1:port1 host2:port2 host3:port3</span><span class="tag">&lt;/value&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;/property&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">&lt;!-- server's weights --&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;property</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"weights"</span><span class="tag">&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;list&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;value&gt;</span><span class="pln">1</span><span class="tag">&lt;/value&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;value&gt;</span><span class="pln">2</span><span class="tag">&lt;/value&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;value&gt;</span><span class="pln">3</span><span class="tag">&lt;/value&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;/list&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;/property&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">&lt;!-- nio connection pool size --&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;property</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"connectionPoolSize"</span><span class="pln"> </span><span class="atn">value</span><span class="pun">=</span><span class="atv">"2"</span><span class="tag">&gt;&lt;/property&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">&lt;!-- Use binary protocol,default is TextCommandFactory --&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;property</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"commandFactory"</span><span class="tag">&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="tag">&lt;bean</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"net.rubyeye.xmemcached.command.BinaryCommandFactory"</span><span class="tag">&gt;&lt;/bean&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;/property&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">&lt;!-- Distributed strategy --&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;property</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"sessionLocator"</span><span class="tag">&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;bean</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"net.rubyeye.xmemcached.impl.KetamaMemcachedSessionLocator"</span><span class="tag">&gt;&lt;/bean&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;/property&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="com">&lt;!-- Serializing transcoder --&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;property</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"transcoder"</span><span class="tag">&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;bean</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"net.rubyeye.xmemcached.transcoders.SerializingTranscoder"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;/property&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">&lt;!-- ByteBuffer allocator --&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;property</span><span class="pln"> </span><span class="atn">name</span><span class="pun">=</span><span class="atv">"bufferAllocator"</span><span class="tag">&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;bean</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"net.rubyeye.xmemcached.buffer.SimpleBufferAllocator"</span><span class="tag">&gt;&lt;/bean&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;/property&gt;</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="tag">&lt;/bean&gt;</span></a></pre><p><a name="与Spring框架集成">配置选项参数表: </a></p><p></p><table><tbody><tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> 属性名 </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> 值 </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> servers </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> memcached节点列表，形如host1:port1 host2:port2的字符串 </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">weights </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">与servers对应的节点的权重，权重越高，连接数越多 </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> connectionPoolSize </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> nio连接池大小，默认为1  </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">commandFactory </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">协议工厂，net.rubyeye.xmemcached.command.BinaryCommandFactory,TextCommandFactory(默认),KestrelCommandFactory </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> sessionLocator </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> 分布策略，一致性哈希net.rubyeye.xmemcached.impl.KetamaMemcachedSessionLocator或者ArraySessionLocator(默认) </td></tr> </tbody></table><p></p><table><tbody><tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">transcoder </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> 序列化转换器，默认使用net.rubyeye.xmemcached.transcoders.SerializingTranscoder，更多选项参见javadoc </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> bufferAllocator </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> IoBuffer分配器，默认为net.rubyeye.xmemcached.buffer.SimpleBufferAllocator，可选CachedBufferAllocator(不推荐) </td></tr> </tbody></table><h3><a name="设置节点权重">设置节点权重</a></h3><p><a name="设置节点权重">如果是通过spring配置，请看上一节，如果需要编程设置，通过下面代码： </a></p><pre class="prettyprint"><a name="设置节点权重"><span class="pln">&nbsp;</span><span class="typ">MemcachedClientBuilder</span><span class="pln"> builder </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> &nbsp; &nbsp; <br></span><span class="typ">XMemcachedClientBuilder</span><span class="pun">(</span><span class="typ">AddrUtil</span><span class="pun">.</span><span class="pln">getAddresses</span><span class="pun">(</span><span class="str">"localhost:12000 localhost:12001"</span><span class="pun">),</span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">[]{</span><span class="lit">1</span><span class="pun">,</span><span class="lit">3</span><span class="pun">});</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="typ">MemcachedClient</span><span class="pln"> memcachedClient</span><span class="pun">=</span><span class="pln">builder</span><span class="pun">.</span><span class="pln">build</span><span class="pun">();</span></a></pre><p><a name="设置节点权重">传入一个int数组，里面的元素就是节点对应的权重值，比如这里设置"localhost:12000"节点的权重为1，而"localhost:12001"的权重为3。注意，xmemcached的权重是通过创建更多是连接来实现的，如果权重为3，那么xmemcached将创建3个连接到该memcached节点，这些连接之间的更新并非同步，这一点需要应用自己注意。 </a></p><p><a name="设置节点权重">改变节点权重，可以通过setServerWeight方法： </a></p><pre class="prettyprint"><a name="设置节点权重"><span class="pln">&nbsp;</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">interface</span><span class="pln"> </span><span class="typ">XMemcachedClientMBean</span><span class="pun">{</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="pun">....</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="com">/**<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* Set a memcached server's weight<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* <br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* @param server<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;* @param weight<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*/</span><span class="pln"><br>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> setServerWeight</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> server</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> weight</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="pun">}</span></a></pre><h3><a name="使用二进制协议">使用二进制协议</a></h3><p><a name="使用二进制协议">如果使用spring配置，请参见与spring集成一节。 </a></p><p><a name="使用二进制协议">Memcached 1.4开始正式启用二进制协议，xmemcached 1.2开始支持二进制协议，启用这一特性也非常简单，设置相应的CommandFactory即可： </a></p><pre class="prettyprint"><a name="使用二进制协议"><span class="typ">MemcachedClientBuilder</span><span class="pln"> builder </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> &nbsp; &nbsp;</span><span class="typ">XMemcachedClientBuilder</span><span class="pun">(</span><span class="typ">AddrUtil</span><span class="pun">.</span><span class="pln">getAddresses</span><span class="pun">(</span><span class="str">"localhost:12000 localhost:12001"</span><span class="pun">),</span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">[]{</span><span class="lit">1</span><span class="pun">,</span><span class="lit">3</span><span class="pun">});</span><span class="pln"><br>&nbsp; &nbsp;builder</span><span class="pun">.</span><span class="pln">setCommandFactory</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">BinaryCommandFactory</span><span class="pun">());</span><span class="com">//use binary protocol </span><span class="pln"><br>&nbsp; &nbsp;</span><span class="typ">MemcachedClient</span><span class="pln"> memcachedClient</span><span class="pun">=</span><span class="pln">builder</span><span class="pun">.</span><span class="pln">build</span><span class="pun">();</span></a></pre><p><a name="使用二进制协议">默认使用的TextCommandFactory，也就是文本协议。 </a></p><h3><a name="JMX支持">JMX支持</a></h3><p><a name="JMX支持">可以通过JMX查看xmemcached的状态，在jvm启动参数中添加： </a></p><pre class="prettyprint"><a name="JMX支持"><span class="pln">&nbsp;java </span><span class="pun">-</span><span class="typ">Dxmemcached</span><span class="pun">.</span><span class="pln">jmx</span><span class="pun">.</span><span class="pln">enable</span><span class="pun">=</span><span class="kwd">true</span></a></pre><p><a name="JMX支持">即可通过JMX监控xmemcached状态，xmemcached通过RMI暴露服务接口： </a></p><pre class="prettyprint"><a name="JMX支持"><span class="pln">&nbsp;service</span><span class="pun">:</span><span class="pln">jmx</span><span class="pun">:</span><span class="pln">rmi</span><span class="pun">:</span><span class="com">///jndi/rmi://[host]:7077/xmemcachedServer </span></a></pre><p><a name="JMX支持">你可以在jconsole中查看这些MBean。 提供的MBean包括: </a></p><table><tbody><tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> MBean </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> 描述 </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">net.rubyeye.xmemcached.monitor.StatisticsHandlerMBean </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> 用于查看Client统计信息 </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">net.rubyeye.xmemcached.impl.OptimizerMBean </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> 用于调整性能参数 </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">net.rubyeye.xmemcached.XMemcachedClientMBean </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">动态添加或者删除节点，查看有效服务器等信息</td></tr> </tbody></table><p><a name="JMX支持">JMX的更多选项: </a></p><table><tbody><tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> 选项 </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> 描述</td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">-Dxmemcached.rmi.port </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> RMI端口 </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">-Dxmemcached.rmi.name </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> RMI服务名 </td></tr> </tbody></table><h3><a name="动态添加/删除节点">动态添加/删除节点</a></h3><p><a name="动态添加/删除节点">在JMX支持一节提到的JMX方式操作外，还可以通过编程方式： </a></p><pre class="prettyprint"><a name="动态添加/删除节点"><span class="pln">&nbsp; &nbsp; </span><span class="typ">MemcachedClient</span><span class="pln"> client</span><span class="pun">=</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">XMemcachedClient</span><span class="pun">(</span><span class="typ">AddrUtil</span><span class="pun">.</span><span class="pln">getAddresses</span><span class="pun">(</span><span class="str">"server1:11211 server2:11211"</span><span class="pun">));</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="com">//Add two new memcached nodes</span><span class="pln"><br>&nbsp; &nbsp;client</span><span class="pun">.</span><span class="pln">addServer</span><span class="pun">(</span><span class="str">"server3:11211 server4:11211"</span><span class="pun">);</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="com">//Remove memcached servers</span><span class="pln"><br>&nbsp; &nbsp;client</span><span class="pun">.</span><span class="pln">removeServer</span><span class="pun">(</span><span class="str">"server1:11211 server2:11211"</span><span class="pun">);</span></a></pre><h3><a name="Nio连接池">Nio连接池</a></h3><p><a name="Nio连接池">Xmemcached是基于java nio的client实现，默认对一个memcached节点只有一个连接，这在通常情况下已经有非常优异的表现。但是在典型的高并发环境下,nio的单连接也会遇到性能瓶颈。因此XMemcached支持设置nio的连接池，允许建立多个连接到同一个memcached节点，但是请注意，这些连接之间是不同步的，因此你的应用需要自己保证数据更新的同步，启用连接池可以通过下面代码：  </a></p><pre class="prettyprint"><a name="Nio连接池"><span class="pln">&nbsp; </span><span class="typ">MemcachedClientBuilder</span><span class="pln"> builder </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> &nbsp; &nbsp;</span><span class="typ">XMemcachedClientBuilder</span><span class="pun">(</span><span class="typ">AddrUtil</span><span class="pun">.</span><span class="pln">getAddresses</span><span class="pun">(</span><span class="str">"localhost:12000"</span><span class="pun">));</span><span class="pln"><br><br>&nbsp; builder</span><span class="pun">.</span><span class="pln">setConnectionPoolSize</span><span class="pun">(</span><span class="lit">5</span><span class="pun">);</span></a></pre><p><a name="Nio连接池">如果采用Spring配置，请参见与Spring集成一节。 </a></p><h3><a name="与Kestrel交互">与Kestrel交互</a></h3><p><a name="与Kestrel交互">Kestrel是twitter开源的一个scala写的简单高效MQ，它支持 memcached文本协议，但是并不完全兼容，例如它不支持flag，导致很多利用flag做序列化的客户端无法正常运作。因此Xmemcached特意提供了KestrelCommandFactory?用于支持Kestrel。使用KestrelCommandFactory?即可拥有如下好处：  </a></p><p><a name="与Kestrel交互"><strong> 默认关闭get优化，因为kestrel不支持bulk get； </strong></a></p><p><a name="与Kestrel交互"><strong> 支持kestrel的阻塞获取和可靠获取； </strong></a></p><p><a name="与Kestrel交互"><strong> 允许向kestrel存储任意java序列化类型。设置KestrelCommandFactory: </strong></a></p><pre class="prettyprint"><a name="与Kestrel交互"><span class="pln">&nbsp;</span><span class="typ">MemcachedClientBuilder</span><span class="pln"> builder </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> &nbsp; &nbsp;</span><span class="typ">XMemcachedClientBuilder</span><span class="pun">(</span><span class="typ">AddrUtil</span><span class="pun">.</span><span class="pln">getAddresses</span><span class="pun">(</span><span class="str">"localhost:12000 localhost:12001"</span><span class="pun">),</span><span class="kwd">new</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">[]{</span><span class="lit">1</span><span class="pun">,</span><span class="lit">3</span><span class="pun">});</span><span class="pln"><br>&nbsp; &nbsp;builder</span><span class="pun">.</span><span class="pln">setCommandFactory</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">KestrelCommandFactory</span><span class="pun">());</span><span class="pln"><br>&nbsp; &nbsp;</span><span class="typ">MemcachedClient</span><span class="pln"> memcachedClient</span><span class="pun">=</span><span class="pln">builder</span><span class="pun">.</span><span class="pln">build</span><span class="pun">();</span></a></pre><p><a name="与Kestrel交互">关于最后一点需要补充说明，由于kestrel不支持flag，因此xmemcached在存储的数据之前加了4个字节的flag，如果你的全部应用都使用xmemcached，那么没有问题，如果使用其他clients，会有兼容性的问题，因此Xmemcached还允许关闭这个功能，通过 </a></p><pre class="prettyprint"><a name="与Kestrel交互"><span class="pln">client</span><span class="pun">.</span><span class="pln">setPrimitiveAsString</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">);</span></a></pre><p><a name="与Kestrel交互">设置为true后，原生类型都将存储为字符串，而序列化类型将无法存储了。  </a></p><h3><a name="与Hibernate-memcached集成">与Hibernate-memcached集成</a></h3><p><a name="与Hibernate-memcached集成">大多数配置与采用spymemcahed一样，具体请看hibernate-memcached的wiki页。如果使用 xmemcached，首先需要将memcacheClientFactory 设置为XmemcachedClientFactory。 </a></p><p></p><table><tbody><tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> <strong>Property</strong> </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> <strong>Value</strong> </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">hibernate.memcached.memcacheClientFactory </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> net.rubyeye.xmemcached.utils.hibernate.XmemcachedClientFactory </td></tr> </tbody></table><p><a name="与Hibernate-memcached集成">其他一般选项有很大不同： </a></p><table><tbody><tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> <strong>Property</strong> </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> <strong>Value</strong> </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">hibernate.memcached.servers </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> localhost:11211 localhost:11212</td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">ibernate.memcached.cacheTimeSeconds </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> 300</td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">hibernate.memcached.keyStrategy    </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> HashCodeKeyStrategy </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">hibernate.memcached.readBufferSize </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">DEFAULT_SESSION_READ_BUFF_SIZE </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">hibernate.memcached.operationTimeout </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">DEFAULT_OP_TIMEOUT </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">hibernate.memcached.hashAlgorithm  </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> NATIVE_HASH,KETAMA_HASH etc.</td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">hibernate.memcached.commandFactory </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> TextCommandFactory , BinaryCommandFactory </td></tr> <tr><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;">hiberante.memcached.sessionLocator </td><td style="border: 1px solid rgb(170, 170, 170); padding: 5px;"> ArrayMemcachedSessionLocator,KetamaMemcachedSessionLocator</td></tr> </tbody></table><h3><a name="压缩、sanitizeKeys等杂项">压缩、sanitizeKeys等杂项</a></h3><h4><a name="数据压缩">数据压缩</a></h4><p><a name="数据压缩">memcached存储大数据的效率是比较低的，当数据比较大的时候xmemcached会帮你压缩在存储，取出来的时候自动解压并反序列化，这个大小阀值默认是16K，可以通过Transcoder接口的setCompressionThreshold(1.2.1引入)方法修改阀值，比如设置为1K： </a></p><pre class="prettyprint"><a name="数据压缩"><span class="pln">memcachedClient</span><span class="pun">.</span><span class="pln">getTranscoder</span><span class="pun">()).</span><span class="pln">setCompressionThreshold</span><span class="pun">(</span><span class="lit">1024</span><span class="pun">);</span></a></pre><p><a name="数据压缩">这个方法是在1.2.1引入到Transcoder接口，在此之前，你需要通过强制转换来设置： </a></p><pre class="prettyprint"><a name="数据压缩"><span class="pln">&nbsp;</span><span class="pun">((</span><span class="typ">SerializingTranscoder</span><span class="pun">)</span><span class="pln">memcachedClient</span><span class="pun">.</span><span class="pln">getTranscoder</span><span class="pun">()).</span><span class="pln">setCompressionThreshold</span><span class="pun">(</span><span class="lit">1024</span><span class="pun">);</span></a></pre><h4><a name="packZeros">packZeros</a></h4><p><a name="packZeros">XMemcached的序列化转换器在序列化数值类型的时候有个特殊处理，如果前面N个字节都是0，那么将会去除这些0，缩减后的数据将更小，例如数字3序列化是0x0003，那么前面3个0将去除掉成一个字节0x3。反序列化的时候将自动在前面根据数值类型补0。这一特性默认是开启的，如果考虑到与其他client兼容的话需要关闭此特性可以通过： </a></p><pre class="prettyprint"><a name="packZeros"><span class="pln">memcachedClient</span><span class="pun">.</span><span class="pln">getTranscoder</span><span class="pun">()).</span><span class="pln">setPackZeros</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span></a></pre><h4><a name="sanitizeKeys">sanitizeKeys</a></h4><p><a name="sanitizeKeys">在官方客户端有提供一个sanitizeKeys选项，当选择用URL当key的时候，MemcachedClient会自动将URL encode再存储。默认是关闭的，想启用可以通过： </a></p><pre class="prettyprint"><a name="sanitizeKeys"><span class="pln">&nbsp;memcachedClient</span><span class="pun">.</span><span class="pln">setSanitizeKeys</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">);</span></a></pre><p><a name="sanitizeKeys">这一特性将在1.2.1中引入。 </a></p>
<!--/DOCUMENT_FRAGMENT-->
</td>
</tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
